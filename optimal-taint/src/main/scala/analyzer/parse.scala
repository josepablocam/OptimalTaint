package analyzer

import java.io.{FileReader, File}

import scala.util.parsing.combinator._
import scala.util.parsing.input._

/**
 * A simple parser for randomly generated java programs that adhere to core-syntax
 * (i.e. as generated by com.github.OptimalTaint.Generate
 */
object parse extends JavaTokenParsers {
  protected override val whiteSpace = """(\s|//.*|(?m)/\*(\*(?!/)|[^*])*\*/)+""".r

  val reserved: Set[String] =
    Set("true", "false", "if", "else",
      "while", "class", "return",
      "static", "int", "long", "void",
      "public"
    )

  val DEFAULT_METHOD_NAME = "run"

  // Java wrapping for our experiments
  def prog(methodName: String): Parser[Com] =
    importStmts ~> classes(methodName) ^^ {
      case (x :: xs) => x
      case Nil => throw new UnsupportedOperationException("only collects commands in " + methodName + " method")
    }

  def importStmt: Parser[String] =
    "import" ~> """[^\n]+""".r

  def importStmts: Parser[List[String]] = importStmt.*

  def classDef(methodName: String): Parser[List[Com]] =
    "class" ~> ident ~> "{" ~> body(methodName) <~ "}"

  def classes(methodName: String): Parser[List[Com]] =
    classDef(methodName).* ^^ { x => x.flatten }

  def body(methodName: String): Parser[List[Com]] =
    method(methodName).* ^^ { x => x.collect { case Some(c) => c } }

  def method(methodName: String): Parser[Option[Com]] =
    ("public" ~> "static" ~> semType ~> ident <~ ignoreBetweenParens <~ "{") ~ com <~ "}" ^^ {
      case found ~ com if found == methodName => Some(com)
      case _ ~ _ => None
    }

  def semType: Parser[String] =
    "int" | "void" | "long" | "double" | "float"

  // Actual core syntaax
  def com: Parser[Com] =
    rep(basicCom) ^^ { cs => Util.simplify(Seq(cs)) }

  def basicCom: Parser[Com] =
    initCom |
      incrCom |
      retCom |
      callCom |
      assignCom |
      whileCom |
      ifCom |
      "{" ~> com <~ "}"

  // for java purposes
  def callCom: Parser[Com] =
    positioned(call ~> ";" ^^ { x => Skip })

  def assignCom: Parser[Com] =
    positioned(ident ~ ("=" ~> aexp <~ ";") ^^ { case id ~ exp => Assign(id, exp) })

  def whileCom: Parser[Com] =
    positioned(
      ("while" ~> "(" ~> ident ~> "<" ~> wholeNumber <~ ")") ~ basicCom ^^
      { case n ~ c1 => While(n.toInt, BExp(Util.uniqueId()), c1) }
    )

  def ifCom: Parser[If] =
    positioned("if" ~> ifCond ~> basicCom ~ ("else" ~> basicCom) ^^ {
      case c1 ~ c2 =>
        If(BExp(Util.uniqueId()), c1, c2, None)
    })

  def ifCond: Parser[String] =
    ignoreBetweenParens ^^ { x => x }

  def ignoreBetweenParens: Parser[String] =
    """\((.*?)\)""".r

  def initCom: Parser[Com] =
    positioned((semType ~> ident <~ "=") ~ aexp <~ ";" ^^ { case id ~ exp => Init(id, exp) })

  def incrCom: Parser[Com] =
    positioned(ident <~ "++" <~ ";" ^^ { id => Incr(id) })

  def retCom: Parser[Com] =
    positioned("return" ~> aexp ~> ";" ^^ { x => Return })

  //parse aexp
  def aexp: Parser[AExp] =
    positioned(call ~ aop ~ aexp ^^ { case v1 ~ _ ~ v2 => AOp(v1, v2) }) |
    call

  def aop: Parser[String] =
    """[-%*/+%]""".r ^^ { case v => v.toString }

  def call: Parser[AExp] =
    positioned(
      ident ~> rep("." ~> ident) ~> "(" ~> aexp ~ rep("," ~> aexp) <~ ")" ^^
      { case x ~ xs => Call(x :: xs) }
    ) |
    positioned(ident ~> rep("." ~> ident) ~> "(" ~> ")" ^^ { x => Call(Nil) }) |
    litOrVar

  // parse variables and integers
  def litOrVar: Parser[AExp] =
    positioned(wholeNumber ^^ { n => AConst(n.toInt) }) |
    positioned(ident ^^ { n => IVar(n) }) |
    positioned(stringLiteral ^^ { s => SConst(s.substring(1, s.length - 1)) }) |
    positioned("(" ~> aexp <~ ")" ^^ { x => x })


  // Utilities
  def fromString(s: String, methodName: String = DEFAULT_METHOD_NAME) = {
    val parser: Parser[Com] = prog(methodName)
    parseAll(parser, s)
  }

  def fromFile(file: File, methodName: String = DEFAULT_METHOD_NAME) = {
    val reader = new FileReader(file)
    val contents = StreamReader(reader)
    val parser: Parser[Com] = prog(methodName)
    parseAll(parser, contents)
  }

}
